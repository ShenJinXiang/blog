id: 75
title: 代理模式
date: 2018-08-07
category: java
tags: java
description: 按照JFinal代码阅读顺序，应该开始拦截器部分了，不过在此之前需要对java代理模式有一定了解，在这里针对代理模式做个总结

------
按照JFinal代码阅读顺序，应该开始拦截器部分了，不过在此之前需要对java代理模式有一定了解，在这里针对代理模式做个总结。

先看看代理模式的定义：
> 给某一个对象提供了一个代理或占位符，并由代理对象来控制原对象的访问。

也就是说，不直接操作目标对象，而是通过代理对象来控制愿对象。对于调用者来说，就好像是在操作目标对象一样的。这样做是有很多好处的，比如可以通过代理对象增强目标对象的功能，可以控制目标对象的调用时机，对目标对象的调用加以约束等。

### 静态代理
<img src='/images/java/2018/08/07/01.png' width='800px' style='display:block; margin:0px auto;'>

静态代理结构比较简单，角色信息有：
* 抽象主题角色（Subject）: 声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
* 代理主题角色（Proxy）： 包含了真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制真实主题的使用，复制在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯地调用真实主题对象中的操作。
* 真实主题角色（RealSubject）： 定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。

#### 代码示例
抽象主题角色Subject
```java
public interface Subject {

    void request(String name);
}
```

真实主题角色RealSubject：
```java
public class RealSubject implements Subject {

    @Override
    public void request(String name) {
        System.out.println("ReadSubject 正在处理请求：" + name);
    }
}
```

代理主题角色Proxy：
```java
public class Proxy implements Subject {

    private Subject subject;

    public Proxy(Subject subject) {
        this.subject = subject;
    }

    private void preRequest() {
        System.out.println("Proxy: 请求处理之前");
    }

    private void postRequest() {
        System.out.println("Proxy: 请求处理之后");
    }

    @Override
    public void request(String name) {
        preRequest();
        this.subject.request(name);
        postRequest();
    }
}
```

客户端调用代码：
```java
public class Client {

    public static void main(String[] args) {
        Subject proxy = new Proxy(new RealSubject());
        proxy.request("请假");
    }
}
```
*运行结果：*
```
Proxy: 请求处理之前
ReadSubject 正在处理请求：请假
Proxy: 请求处理之后
```

静态代理可以通过代理类增强、控制目标类。但是也有不足，那就是需要针对每个目标类编写对应的代理类，而实际的业务有可能是重复的，类过于庞大，且维护成本过高。所以需要使用动态代理技术。

### JDK动态代理
JDK动态代理是java.lang.reflect.*包提供的一种代理实现方式，要用JDK动态代理必须借助接口才能产生代理对象，先创建目标接口和接口：
```java
public interface Hello {

    void sayHello(String name);
}
```

实现类：
```java
public class HelloImpl implements Hello {

    @Override
    public void sayHello(String name) {
        System.out.println("Hello " + name);
    }
}
```

使用JDK动态代理，实现代理逻辑必须实现`java.lang.reflect.InvocationHandler`接口：
```java
public class JdkProxy implements InvocationHandler {

	/**
	 * 真实对象
	 */
    private Object target;

	/**
	 * 建立代理对象和真实对象的代理关系，并返回代理对象
	 * @param target 真实对象
	 * @return 代理对象
	 */
    public Object bind(Object target) {
        this.target = target;
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
    }

	/**
	 * 代理方法逻辑
	 * @param proxy 代理对象
	 * @param method 当前调度的方法
	 * @param args 当前调度的方法的参数
	 * @return 代理结果返回
	 */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("执行真实对象的业务之前");

		// 调用真实对象的方法
        Object result = method.invoke(target, args);

        System.out.println("执行真实对象的业务之后");
        return result;
    }
}
```
测试代码：
```java
public class JdkProxyTest {

    @Test
    public void test() {
        JdkProxy proxy = new JdkProxy();
        Hello hello = (Hello) proxy.bind(new HelloImpl());
        hello.sayHello("ShenJinXiang");
    }
}
```
*运行结果：*
```
执行真实对象的业务之前
Hello ShenJinXiang
执行真实对象的业务之后
```

在`JdkProxy`中，通过`bind`方法创建代理对象：
1. 首先用私有域`target`保存了真实对象
2. 通过`Proxy.newProxyInstance()`方法创建代理对象

newProxyInstance()方法包含3哥参数：
* classLoader：类加载，这里采用了target本身的类加载
* interfaces：接口数组，JDK动态代理是通过创建与真实类相同接口的代理类来实现的，所以需要知道真实类实现的接口。这里直接获取target的接口列表
* InvocationHandler：定义实现方法逻辑的代理类，这里使用了this，即当前对象，需实现`InvocationHandler`接口的`invoke`方法。

继续看JdkProxy的代码，没有写具体的真实对象名称之类的，所以如果需要代理其他的类，只需要调用的时候通过bind方法，绑定真实对象，即可获取到代理对象：


```java
```
